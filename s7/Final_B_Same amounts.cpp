/*
Задача: B.Одинаковые суммы

Описание.
Решение задачи с помощью динамического программирования. 
Дано множество чисел s{x1 ... xn}. 
Найдем сумму sum всех чисел данного множества. 
Если множество можно поделить на два таких подмножества, что сумма одного будет равна сумме другого, то
подразумевается, что сумма каждого подмножества будет равна k = sum/2. 
Соответственно sum должен быть четным числом и делиться без остатка. 
Если sum нечетное число, то сразу выдает ответ False, если четная, то применяем динамическое программирование
для определения возможности разбития множества. 

Базовый случай
dp[0] равен true

Переход динамики
Для каждого элемента множества elem
	Для i[k...elem]
		dp[i] принимает значение true, когда
			dp[i] равен true
			или
			dp[i - elem] равен true
			в противном случае false.
			
Целью алгоритма вычислить значение dp[k]

ВРЕМЕННАЯ СЛОЖНОСТЬ
Если сумма всех элементов множества нечетная
O(n), где n - количество элементов множества.
В худшем случае O(sum*n)
где n - количество элементов множества, sum - сумма всех элементов множества

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ
Используется дополнительная память под массив dp O(k),
где k - половина сумму всех элементов множества
*/

#include <iostream>
#include <numeric>
#include <vector>

int main() {
	int n;
	std::vector<int> s;

	std::cin >> n;

	for (int i = 0; i < n; ++i) {
		int x;
		std::cin >> x;
		s.push_back(x);
	}

	int sum = std::accumulate(s.begin(), s.end(), 0);

	if (sum % 2 != 0) {
		std::cout << "False";
	}
	else {
		int k = sum / 2;
		std::vector<bool> dp(k + 1);
		dp[0] = true;

		for (int digit: s) {
			for (int i = k; i >= digit; --i) {
				dp[i] = dp[i] || dp[i - digit];
			}
		}
		std::cout << (dp[k] == true ? "True" : "False");
	}
}