/*
Задача. B. Железные дороги
Описание.
Проверка карты на оптимальность. Между городами существуют два типа маршрута B и R.
Карта является оптимальной если не существует пары городов A и B такой, 
что от A до B можно добраться как по дорогам типа R, так и по дорогам типа B.
По условию задачи по дорогам можно двигаться только от города с меньшим номером к городу с большим номером.
Представим карту в виде ориентированного графа, в котором ребра типа В будут от меньшего номера вершины к большему, а типа R наоборот от большего к меньшему.  

Рассмотрим пример с циклом: 
1->3=>2->4=>1.
В данном примере цикл из 4-х вершин. В примере не хватает ребер 1-2 и 3-4, которые обязательно должны быть по условию задачи.  
Если мы в наш пример добавим любое недостающее ребро с любым типом дороги, то получим цикл состоящий из трех вершин.
Добавим ребро 1->2, тода получится цикл: 1->2->4=>1
Добавим ребро 2=>1, тода получится цикл: 1->3=>2=>1
Добавим ребро 3->4, тода получится цикл: 1->3->4=>1
Добавим ребро 4=>3, тода получится цикл: 3=>2->4=>3

Из примера видно, что цикл образуется дугами двух типов B и R, наличие которого указывает на то что карта является неоптимальной. 
Следовательно задача сводится к проверке наличия циклов в графе.

Поиск цикла осуществляем при помощи алгоритма обхода в глубину DFS. 
Для удобства запоминания посещенных вершин заводим перечисляемый тип Color, которым помечаем вершины следующим образом: 
белым цветом помечены непосещеные вершины;  
серым вершины, которые посещены, но еще не обработаны; 
черным - обработанные вершины.
Если при проверке смежных по исходящим дугам вершин очередная вершина окажется серой, то цикл есть. 

ВРЕМЕННАЯ СЛОЖНОСТЬ
Временная сложность зависит от количества вершин и ребер графа. В худшем случае обходом в глубину необходимо пройтись по всем вершинам.
перебрав все ребра, исходящие из каждой вершины.
Сложность получится О(V+E), где V - количество вершин, E - количество ребер. 

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ
Алгоритмом обхода в глубину используется дополнительная память под массив с цветами вершин О(n). 
Также испльзуется дополнительная память под стек, в который вкладываются посещаемые вершины О(n).
*/

#include <algorithm>
#include <iostream>
#include <stack>
#include <vector>

enum class Color {
	white, 
	gray, 
	black
};

bool FindCycle(int start, const std::vector<std::vector <int>>& graph, std::vector<Color>& color) {
	std::stack<int> st;
	st.push(start);

	while (!st.empty()) {
		switch (color[st.top()]) {
			case Color::white: 
				color[st.top()] = Color::gray;
				for (int v : graph[st.top()]) {
					if (color[v] == Color::gray) {
						return false;
					}
					st.push(v);
				}
				break;
			case Color::gray: 
				color[st.top()] = Color::black;
				st.pop(); 
				break;
			case Color::black: 
				st.pop(); 
				break;
		}
	}
	return true;
}

int main() {
	int n;
	std::cin >> n;

	std::vector<std::vector <int>> graph(n + 1);
	std::vector<Color> color(n + 1, Color::white);

	for (int i = 1; i < n; ++i) {
		std::string line;
		std::cin >> line;
		int j = i + 1;
		for (char ch : line) {
			switch (ch) {
				case 'B': graph[i].push_back(j); break;
				case 'R': graph[j].push_back(i); break;
			}
			++j;
		}
	}

	auto iter = std::find(color.begin(), color.end(), Color::white);

	while (iter != color.end()) {
		if (!FindCycle((iter - color.begin()), graph, color)) {
			std::cout << "NO";
			return 0;
		}
		iter = std::find(iter, color.end(), Color::white);
	}

	std::cout << "YES";
}